<!DOCTYPE html>
    <html lang="ko">
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Vampire Survivors Prototype</title>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background-color: #222;
                color: white;
                font-family: Arial, sans-serif;
            }
            canvas {
                display: block;
                margin: auto;
                background-color: #c6dee3;
            }
            #score {
                position: absolute;
                top: 10px;
                left: 10px;
                font-size: 20px;
            }
        </style>
    </head>
    <body>
        <div id="score">Score: 0</div>
        <canvas id="gameCanvas"></canvas>
        <script type="module">
            const canvas = document.getElementById('gameCanvas');
            // 캔버스에 그래픽을 그리거나 조작하는데 이용
            const ctx = canvas.getContext('2d');
            // 크기 조정
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            let previousTime = null;
            let closestMonster = {};
            let keys = {};
            let gameOver = false;
            let damaged = false;
            let getItem = false;
            let player = {
              x: canvas.width / 2,
              y: canvas.height / 2,
              size: 20,
              score: 0,
              health: 3,
              damage: 2,
              speed: 300,
            }

            let monsters = [];
            function spawnMonster() {
              const size = Math.trunc(Math.random() * 20) + 10;
              monsters.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                health: 3,
                defense: 1,
                speed: 150,
                preDirection: 0,
                score: 10,
                size
              });
            }

            let bullets = [];
            function shootBullets(shooter, target) {
              const size = 10
              if(("x" in target)) {
                bullets.push({
                  x: shooter.x,
                  y: shooter.y,
                  damage: shooter.damage,
                  speed: 2000,
                  // 방향 확인
                  angle: Math.atan2(target.y - shooter.y, target.x - shooter.x),
                  size
                });
              }
            }

            let items = [];
            function spawnItem() {
              const size = 25
              items.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                damage: 1,
                health: 1,
                defense: 0,
                speed: 5,
                score: 5,
                size
              });
            }

            // 충돌 감지
            const colliedWith = (a, b) => {
              // a의 왼쪽이 b의 오른쪽보다 왼쪽에 있을 때
              return (a.x < b.x + b.size &&
                // a의 오른쪽이 b의 왼쪽보다 오른쪽에 있을 때
                a.x + a.size > b.x &&
                // a의 위가 b의 아래보다 위에 있을 때
                a.y < b.y + b.size &&
                // a의 아래가 b의 위보다 아래에 있을 때
                a.y + a.size > b.y)
            }

            // 게임 Loop
            function update(currentTime) {
              //deltaTime을 구하기 위한 로직
              // deltaTime = 모든 환경에서 같은 게임 속도를 유지하기 위해 구하는 값
              // 프레임 렌더링 속도 (단위: 초)
              if (previousTime === null) {
                previousTime = currentTime;
                requestAnimationFrame(update);
                return;
              }
              const deltaTime = (currentTime - previousTime) * 0.001
              previousTime = currentTime;

              //초마다 score +1 
              player.score += deltaTime 

              // 캔버스 초기화
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              // 플레이어 생성
              ctx.fillStyle = 'blue';
              ctx.fillRect(player.x, player.y, player.size, player.size);

              // 체력바 배경
              ctx.fillStyle = 'black';
              ctx.fillRect(player.x, player.y - 10, player.size, 5);
              // 체력 1칸당 비율
              const healthPerUnit = player.size / 3; 
              // 체력바 그리기
              for (let i = 0;i < 3;i++) {
                // 현재 체력 
                if (i < player.health) {
                  ctx.fillStyle = 'green';
                  ctx.fillRect(player.x + i * healthPerUnit, player.y - 10, healthPerUnit, 5);  
                } 
                if (i < 2) {
                  // 구분 줄
                  ctx.fillStyle = 'black';
                  ctx.fillRect(player.x + (i + 1) * healthPerUnit, player.y - 10, 2, 5);
                }
              }

              // 근접 몬스터 찾기용 변수
              let closestDistance = Infinity;
              // monster 그리기
              monsters.forEach((monster, index) => {
                //방향과 각도 찾기
                const direction = Math.atan2(player.y - monster.y, player.x - monster.x)
                const currentDirection = direction * (180 / Math.PI)
                let accSpeed = 0;

                // 관성 적용
                if (monster.preDirection === 0) {
                  monster.preDirection = currentDirection
                } else {
                  // 방향 각도 차이가 30도 아래이면 가속
                  if ( Math.abs(monster.preDirection - currentDirection) <= 30) {
                    accSpeed = 20
                  // 방향 각도 차이가 100도 이상이면 감속
                  } else if (Math.abs(monster.preDirection - currentDirection) > 100) {
                    accSpeed = -10
                  // 적절한 진로 변경은 상관 없음
                  } else {
                    accSpeed = 0
                  }

                  // 이동속도가 0이 되는 걸 방지
                  if (monster.speed + accSpeed < 0) {
                    accSpeed = 1 - monster.speed 
                  }
                }

                monster.x += Math.cos(direction) * (monster.speed + accSpeed) * deltaTime
                monster.y += Math.sin(direction) * (monster.speed + accSpeed) * deltaTime

                ctx.fillStyle = 'red';
                ctx.fillRect(monster.x, monster.y, monster.size, monster.size);

                //플레이어와 가까운 몬스터 찾기
                const dx = monster.x - player.x;
                const dy = monster.y - player.y;
                const distance = Math.hypot(dx, dy);
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestMonster = monster;
                }

                // 체력이 0이 될 경우 삭제
                if (monster.health < 1) {
                  player.score += monster.score
                  monsters.splice(index, 1);
                }
              });

              // 탄환 그리기
              bullets.forEach((bullet, index) => {
                bullet.x += Math.cos(bullet.angle) * bullet.speed * deltaTime
                bullet.y += Math.sin(bullet.angle) * bullet.speed * deltaTime

                ctx.fillStyle = 'yellow';
                ctx.fillRect(bullet.x, bullet.y, bullet.size, bullet.size);

                //몬스터와 충돌 감지
                const monsterIndex = monsters.findIndex((monster) => colliedWith(bullet, monster))
                if(monsterIndex !== -1) { 
                  // 몬스터 데미지 적용
                  const damage = bullet.damage - monsters[monsterIndex].defense;
                  monsters[monsterIndex].health -=  damage > 0 ? damage : 0;
                  //총알 제거 
                  bullets.splice(index, 1);
                }
                
                // 화면 밖으로 나가면 제거
                if (bullet.y > canvas.height || bullet.x > canvas.width) {
                  bullets.splice(index, 1);
                }
              });

              // 아이템 그리기
              items.forEach((item) => {
                ctx.fillStyle = 'purple';
                ctx.fillRect(item.x, item.y, item.size, item.size);
              });

              // 아이템 획득
              const itemIndex = items.findIndex((item) => colliedWith(item, player))
              if (!getItem && itemIndex !== -1 ) {
                getItem = true;
                // 아이템 스탯 적용
                player.damage += items[itemIndex].damage
                // 최대 체력인 3보다 적을 때만 회복
                player.health += player.health < 3 ? items[itemIndex].health : 0
                player.defense += items[itemIndex].defense
                player.speed += items[itemIndex].speed
                player.score += items[itemIndex].score
                // 아이템 삭제
                items.splice(itemIndex, 1)
                getItem = false;
              }

              // 몬스터 피격
              if (!damaged && monsters.some((monster) => colliedWith(monster, player))) {
                damaged = true;
                player.health--
                setInterval(() => damaged = false, 1500)
              }

              // 게임오버
              if (!gameOver && player.health < 1) {
                alert('Game Over! Your score: ' + Math.floor(player.score).toString().padStart(6, 0));
                gameOver = true;
                document.location.reload();
              }

              // 플레이어 화면의 점수 업데이트
              document.getElementById('score').innerText = 'Score: ' + Math.floor(player.score).toString().padStart(6, 0);

              // 플레이어의 이동
              if ((keys['ArrowUp'] || keys["w"] || keys["ㅈ"]) && player.y > 0) player.y -= player.speed  * deltaTime;
              if ((keys['ArrowDown'] || keys["s"] || keys["ㄴ"]) && player.y < canvas.height - player.size) player.y += player.speed * deltaTime;
              if ((keys['ArrowLeft'] || keys["a"] || keys["ㅁ"]) && player.x > 0) player.x -= player.speed * deltaTime;
              if ((keys['ArrowRight'] || keys["d"] || keys["ㅇ"]) && player.x < canvas.width - player.size) player.x += player.speed * deltaTime;

              // 애니메이션화 60fps + 재귀호출로 반복
              requestAnimationFrame(update);
            }

            // 키 맵핑
            window.addEventListener('keydown', (e) => {
                keys[e.key] = true;
            });
            window.addEventListener('keyup', (e) => {
                keys[e.key] = false;
            });


            setInterval(spawnItem, 3000); // 3초마다 아이템 생성
            setInterval(spawnMonster, 1000); // 1초마다 적 생성
            setInterval(() => {shootBullets(player, closestMonster)}, 500); // 0.5초마다 탄환 발사
            requestAnimationFrame(update);
        </script>
  </body>
</html>